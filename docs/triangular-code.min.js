/**
 * @license
 * https://github.com/lizongying/triangular-code
 */
import ReedSolomon from"reed-solomon";class TriangularCode{constructor(t,e=200,s="green",i="white",o=""){this.container=t;this.scale=Math.sin(this.degreesToRadians(60));this._svgNamespace="http://www.w3.org/2000/svg";this.color=s;this.colorBackground=i;this.text=o;this.updateSize(e)}updateSize(t){this.size=t;const e=this.container;let s=e.querySelector("svg");if(s){while(s.firstChild){s.removeChild(s.firstChild)}}else{s=document.createElementNS(this._svgNamespace,"svg");s.setAttribute("transform",`scale(1,${this.scale})`);e.appendChild(s)}s.setAttribute("width",`${t}`);s.setAttribute("height",`${t}`);s.setAttribute("viewBox",`0 0 ${t} ${t}`);this._svg=s;this.encode()}updateText(t){this.text=t;const e=this.container;let s=e.querySelector("svg");if(s){while(s.firstChild){s.removeChild(s.firstChild)}}else{s=document.createElementNS(this._svgNamespace,"svg");s.setAttribute("transform",`scale(1,${this.scale})`);e.appendChild(s)}this._svg=s;this.encode()}degreesToRadians(t){return t*(Math.PI/180)}stringToBinary(t){const e=new TextEncoder;const s=e.encode(t);return Array.from(s).flatMap((t=>t.toString(2).padStart(8,"0").split(""))).map(Number)}encode(t=this.text){this.text=t;const e=this.color;const s=this.colorBackground;let i=this.stringToBinary(t);console.log("data",i);const o=5;const l=2;const n=new ReedSolomon(o,l);const r=n.encode(i);console.log("Encoded Data:",r);const c=r.slice(0,-2).concat([0,0]);const a=new ReedSolomon(o,l);const h=a.decode(c);console.log("Decoded Data:",h);if(i.length<32){i=i.concat(new Array(32-i.length).fill(0))}let d=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0];if(i.length>32){d=d.concat([0])}d=d.concat(i);let g=[0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,1,1,1,1,1,1,1];let u=d.length+25;let f=Math.ceil(Math.sqrt(u));let m=this.size/f;let p=0;let v=0;for(let t=0;t<f;t++){let i=2*t+1;if(t>f-6){i-=(5-(f-t))*2+1;let o=t-(f-5);let l=2*o+1;for(let i=0;i<l;i++){let l=this.size-5/2*m-o*m/2;let n=t*m;let r;let c;let a;if(i%2===0){r=[l+i*m/2,n];c=[l+i*m/2-m/2,n+m];a=[l+(i*m/2+m/2),n+m]}else{r=[l+i*m/2,n+m];c=[l+i*m/2-m/2,n];a=[l+(i*m/2+m/2),n]}const h=document.createElementNS(this._svgNamespace,"polygon");h.setAttribute("points",`${r.join(",")} ${c.join(",")} ${a.join(",")}`);if(v<g.length&&g[v]===1){h.setAttribute("fill",e)}else{h.setAttribute("fill",s)}this._svg.appendChild(h);v++}}for(let o=0;o<i;o++){let i=this.size/2-t*m/2;let l=t*m;let n;let r;let c;if(o%2===0){n=[i+o*m/2,l];r=[i+o*m/2-m/2,l+m];c=[i+(o*m/2+m/2),l+m]}else{n=[i+o*m/2,l+m];r=[i+o*m/2-m/2,l];c=[i+(o*m/2+m/2),l]}const a=document.createElementNS(this._svgNamespace,"polygon");a.setAttribute("points",`${n.join(",")} ${r.join(",")} ${c.join(",")}`);if(p<d.length&&d[p]===1){a.setAttribute("fill",e)}else{a.setAttribute("fill",s)}this._svg.appendChild(a);p++}}}}